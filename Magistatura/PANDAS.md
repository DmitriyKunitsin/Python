# Шпаргалка по PANDAS

- <span style="background-color: red;">**read_table()**</span> – загружает данные из текстовых файлов с разделителями (по умолчанию табуляция). Для других разделителей можно использовать параметр sep.
- <span style="background-color: red;"> **.head()** </span>– отображает первые n строк DataFrame (по умолчанию 5).
- <span style="background-color: red;">**.info()** </span> – предоставляет информацию о DataFrame, включая количество ненулевых значений и типы данных.
- <span style="background-color: red;">**.drop(labels, axis)**</span> – даляет строки или столбцы. Параметр axis=0 для строк и axis=1 для столбцов.
- <span style="background-color: red;">**.dtypes**</span> – возвращает типы данных каждого столбца в DataFrame.
- <span style="background-color: red;">**.astype(), to_datetime(), .to_numeric()**</span> – используются для преобразования типов данных. Например, to_datetime() может преобразовать строки в формат даты.
- <span style="background-color: red;">**.isnull().sum()**</span> –  вычисляет количество пропущенных значений в каждом столбце
- <span style="background-color: red;">**.max(), .min(), .mean()**</span> –  вычисляют максимум, минимум и среднее значение для числовых столбцов.
- <span style="background-color: red;">**pd.Grouper(), .groupby()**</span> – позволяют группировать данные по одному или нескольким столбцам, а также по временным интервалам.
- <span style="background-color: red;">**.agg(func)**</span> – агрегирует данные по заданной функции (например, sum, mean и т.д.) после группировки.
- <span style="background-color: red;">**.truncate(before, after)**</span> – позволяет обрезать DataFrame по индексам или датам. Полезно для работы с временными рядами.

- <span style="background-color: red;">**df = pd.DataFrame()**</span> - Это может пригодиться тогда, когда нужно вручную ввести в программу простые данные. Например — если нужно оценить изменения, претерпеваемые данными, проходящими через конвейер обработки данных.
``` 
df = pd.DataFrame([[1,'Bob', 'Builder'],
                  [2,'Sally', 'Baker'],
                  [3,'Scott', 'Candle Stick Maker']], 
columns=['id','name', 'occupation']) 
```

- <span style="background-color: red;">**.copy(deep=True)**</span> - Копирование датафреймов может пригодиться в ситуациях, когда требуется внести в данные изменения, но при этом надо и сохранить оригинал. Если датафреймы нужно копировать, то рекомендуется делать это сразу после их загрузки.
```
anime_copy = anime.copy(deep=True)
```
- <span style="background-color: red;">**.to_csv('saved_ratings.csv', index=False)**</span> - При экспорте данных они сохраняются в той же папке, где находится блокнот. Ниже показан пример сохранения первых 10 строк датафрейма, но то, что именно сохранять, зависит от конкретной задачи.

```
rating[:10].to_csv('saved_ratings.csv', index=False)
```
<span style="background-color: red;">**Экспортировать данные в виде Excel-файлов можно с помощью функции df.to_excel.**</span>

- <span style="background-color: red;">**anime.head(3) rating.tail(1).truncate(before, after)**</span> - Сначала поговорим о выводе первых n элементов датафрейма. Я часто вывожу некоторое количество элементов из начала датафрейма где-нибудь в блокноте. Это позволяет мне удобно обращаться к этим данным в том случае, если я забуду о том, что именно находится в датафрейме. Похожую роль играет и вывод нескольких последних элементов.

- <span style="background-color: red;">**len()**</span> - Функция len(), которую я тут покажу, не входит в состав pandas. Но она хорошо подходит для подсчёта количества строк датафреймов. Результаты её работы можно сохранить в переменной и воспользоваться ими там, где они нужны.
```
len(df)
#=> 3
```

- <span style="background-color: red;">**.unique()**</span> - Для подсчёта количества уникальных значений в столбце можно воспользоваться такой конструкцией:
```
len(ratings['user_id'].unique())
```
- <span style="background-color: red;">**.info()**</span> - В сведения о датафрейме входит общая информация о нём вроде заголовка, количества значений, типов данных столбцов.
```
anime.info()
```
<span style="background-color: red;">**Есть ещё одна функция, похожая на df.info — df.dtypes. Она лишь выводит сведения о типах данных столбцов.**</span>

- <span style="background-color: red;">**.describe()**</span> - Знание статистических сведений о датафрейме весьма полезно в ситуациях, когда он содержит множество числовых значений. Например, знание среднего, минимального и максимального значений столбца rating даёт нам некоторое понимание того, как, в целом, выглядит датафрейм. Вот соответствующая команда:
```
anime.describe()
```

- <span style="background-color: red;">**.value_counts()**</span> - Для того чтобы подсчитать количество значений в конкретном столбце, можно воспользоваться следующей конструкцией:
```
anime.type.value_counts()
```

- <span style="background-color: red;">**.tolist()**</span> - 
Это может пригодиться в тех случаях, когда требуется извлекать значения столбцов в переменные x и y для обучения модели. Здесь применимы следующие команды:

```
anime['genre'].tolist()
anime['genre']
```

- <span style="background-color: red;">**.index.tolist()**</span> - Поговорим о получении списков значений из индекса. Обратите внимание на то, что я здесь использовал датафрейм anime_modified, так как его индексные значения выглядят интереснее.

```
anime_modified.index.tolist()
```

- <span style="background-color: red;">**.columns.tolist()**</span> - Вот команда, которая позволяет получить список значений столбцов:
``` 
anime.columns.tolist()
```

### Присоединение к датафрейму нового столбца с заданным значением
#### Иногда мне приходится добавлять в датафреймы новые столбцы. Например — в случаях, когда у меня есть тестовый и обучающий наборы в двух разных датафреймах, и мне, прежде чем их скомбинировать, нужно пометить их так, чтобы потом их можно было бы различить. Для этого используется такая конструкция:


```
anime['train set'] = True
```

### Создание нового датафрейма из подмножества столбцов
#### Это может пригодиться в том случае, если требуется сохранить в новом датафрейме несколько столбцов огромного датафрейма, но при этом не хочется выписывать имена столбцов, которые нужно удалить.

```
anime[['name','episodes']]
```

### Удаление заданных столбцов
#### Этот приём может оказаться полезным в том случае, если из датафрейма нужно удалить лишь несколько столбцов. Если удалять нужно много столбцов, то эта задача может оказаться довольно-таки утомительной, поэтому тут я предпочитаю пользоваться возможностью, описанной в предыдущем разделе.
```
anime.drop(['anime_id', 'genre', 'members'], axis=1).head()
```
### Добавление в датафрейм строки с суммой значений из других строк
#### Для демонстрации этого примера самостоятельно создадим небольшой датафрейм, с которым удобно работать. Самое интересное здесь — это конструкция df.sum(axis=0), которая позволяет получать суммы значений из различных строк.
```
df = pd.DataFrame([[1,'Bob', 8000],
                  [2,'Sally', 9000],
                  [3,'Scott', 20]], columns=['id','name', 'power level'])
df.append(df.sum(axis=0), ignore_index=True)
```
<span style="background-color: red;">**Команда вида df.sum(axis=1) позволяет суммировать значения в столбцах. 
Похожий механизм применим и для расчёта средних значений. Например — df.mean(axis=0)**</span>

### Комбинирование датафреймов
#### Эта методика применима в ситуациях, когда имеются два датафрейма с одинаковыми столбцами, которые нужно скомбинировать. В данном примере мы сначала разделяем датафрейм на две части, а потом снова объединяем эти части:
```
df1 = anime[0:2]
df2 = anime[2:4]
pd.concat([df1, df2], ignore_index=True)
```

### Слияние датафреймов
#### Функция df.merge, которую мы тут рассмотрим, похожа на левое соединение SQL. Она применяется тогда, когда два датафрейма нужно объединить по некоему столбцу.

```
rating.merge(anime, left_on=’anime_id’, right_on=’anime_id’, suffixes=(‘_left’, ‘_right’))
```

### Фильтрация
#### Получение строк с нужными индексными значениями
- Индексными значениями датафрейма anime_modified являются названия аниме. Обратите внимание на то, как мы используем эти названия для выбора конкретных столбцов

```
anime_modified.loc[['Haikyuu!! Second Season','Gintama']]
```

#### Получение строк по числовым индексам
- Эта методика отличается от той, которая описана в предыдущем разделе. При использовании функции df.iloc первой строке назначается индекс 0, второй — индекс 1, и так далее. Такие индексы назначаются строкам даже в том случае, если датафрейм был модифицирован и в его индексном столбце используются строковые значения.

#### Следующая конструкция позволяет выбрать три первых строки датафрейма:
```
anime_modified.iloc[0:3]
```

#### Получение строк по заданным значениям столбцов
- Для получения строк датафрейма в ситуации, когда имеется список значений столбцов, можно воспользоваться следующей командой:
```
anime[anime['type'].isin(['TV', 'Movie'])]
```

#### Если нас интересует единственное значение — можно воспользоваться такой конструкцией:
```
anime[anime[‘type’] == 'TV']
```

### Получение среза датафрейма
 - Эта техника напоминает получение среза списка. А именно, речь идёт о получении фрагмента датафрейма, содержащего строки, соответствующие заданной конфигурации индексов.
```
anime[1:3]
```
### Фильтрация по значению
- Из датафреймов можно выбирать строки, соответствующие заданному условию. Обратите внимание на то, что при использовании этого метода сохраняются существующие индексные значения.
```
anime[anime['rating'] > 8]
```

### Сортировка
- Для сортировки датафреймов по значениям столбцов можно воспользоваться функцией df.sort_values:
```
anime.sort_values('rating', ascending=False)
```

### Агрегирование

#### Функция df.groupby и подсчёт количества записей
- Вот как подсчитать количество записей с различными значениями в столбцах:
``` 
anime.groupby('type').count()
```

#### Функция df.groupby и агрегирование столбцов различными способами
- Обратите внимание на то, что здесь используется reset_index(). В противном случае столбец type становится индексным столбцом. В большинстве случаев я рекомендую делать то же самое.
```
anime.groupby(["type"]).agg({
  "rating": "sum",
  "episodes": "count",
  "name": "last"
}).reset_index()
```

#### Создание сводной таблицы
- Для того чтобы извлечь из датафрейма некие данные, нет ничего лучше, чем сводная таблица. Обратите внимание на то, что здесь я серьёзно отфильтровал датафрейм, что ускорило создание сводной таблицы.
```
tmp_df = rating.copy()
tmp_df.sort_values('user_id', ascending=True, inplace=True)
tmp_df = tmp_df[tmp_df.user_id < 10] 
tmp_df = tmp_df[tmp_df.anime_id < 30]
tmp_df = tmp_df[tmp_df.rating != -1]
pd.pivot_table(tmp_df, values='rating', index=['user_id'], columns=['anime_id'], aggfunc=np.sum, fill_value=0)
```

### Очистка данных
#### Запись в ячейки, содержащие значение NaN, какого-то другого значения
- Здесь мы поговорим о записи значения 0 в ячейки, содержащие значение NaN. В этом примере мы создаём такую же сводную таблицу, как и ранее, но без использования fill_value=0. А затем используем функцию fillna(0) для замены значений NaN на 0
```
pivot = pd.pivot_table(tmp_df, values='rating', index=['user_id'], columns=['anime_id'], aggfunc=np.sum)
pivot.fillna(0)
```
###  Другие полезные возможности
#### Отбор случайных образцов из набора данных
- Я использую функцию df.sample каждый раз, когда мне нужно получить небольшой случайный набор строк из большого датафрейма. Если используется параметр frac=1, то функция позволяет получить аналог исходного датафрейма, строки которого будут перемешаны.
```
anime.sample(frac=0.25)
```
#### Перебор строк датафрейма
- Следующая конструкция позволяет перебирать строки датафрейма:
```
for idx,row in anime[:2].iterrows():
    print(idx, row)
```